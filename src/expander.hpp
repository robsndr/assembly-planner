#pragma once

#include <vector>
#include <set>

#include "combinator.hpp"
#include "graph.hpp"
// #include "types.hpp"

/* Class representing the node-expander.
    During the A* search the supernodes need to be expanded.
    This class handles the expansion-step and creates new hypernodes for the A* search_graph.
    It is important to denote that the search itself is performed on a graph of "HyperNodes".
    Every Hypernode contains references to the nodes of the original And/Or graph.
    If interactions are necessary, their insertion into the HyperNodes is handled inside the Expander.
**/
class NodeExpander
{

public:
    // Constructr / Destructor
    NodeExpander(Graph<NodeData,EdgeData>&, Graph<NodeData,EdgeData>&, config::Configuration&);

    // Node Expansion function.
    // Called by the A*-search on evary iteration.
    void expandNode(NodeIndex);

private:
    // Function used to create Interactions if subassemblies are not reachable.
    NodeIndex createInteraction(NodeIndex, NodeData&, std::string, double);

    // Pointer to the graph of HyperNodes on which the A* search runs.
    Graph<NodeData,EdgeData>& assembly_graph_;
    Graph<NodeData,EdgeData>& search_graph_;

    // Pointers to cost/reach maps provided by the InputReader.
    config::Configuration& config;

    // Assgnemtn generation object and assignemnt container
    Combinator assignment_generator_;
};

/* NodeExpander Constructor.
**/
NodeExpander::NodeExpander(Graph<NodeData,EdgeData>& origin_graph, Graph<NodeData,EdgeData>& graph, config::Configuration& conf) 
  : config(conf), 
    assignment_generator_(config), 
    assembly_graph_(origin_graph), 
    search_graph_(graph) 
{}

/* Function which performs the node expansion.
**/
void NodeExpander::expandNode(NodeIndex node_id)
{
    std::vector<NodeIndex> nodes;

    auto& node_data = search_graph_.getNodeD(node_id);
    for (auto sa : node_data.subassemblies)
    {
        if (assembly_graph_.numberOfSuccessors(sa.second) > 0)
            nodes.push_back(NodeIndex(sa.second));
    }

    // Obtain all possible assignement cominations of agents to actions for the current step.
    // The assignment combinations are generated by the Combinator Object.
    const auto assignments_ = assignment_generator_.generateAgentActionAssignments(assembly_graph_, nodes);

    // Declare the min/ma cost which needs to be set below.
    double min_action_agent_cost_ = node_data.minimum_cost_action;
    double max_action_agent_cost_ = 0;

    // Iterate through all possible assignments of agents to available actions.
    for (const auto& cur_assignments : assignments_)
    {
        // Create the data for the created supernode.
        // Temporary node data
        NodeData x;
        x.subassemblies = node_data.subassemblies;
        x.actions = node_data.actions;
        x.marked = false;
        // Temporary edge data
        EdgeData y;
        y.cost = 0;

        // Counter variable. Needed to calculate the average cost for the connecting edge.
        int iters = 0;

        // Iterate through agent-action pairs for the current assignemnt
        for (const auto& assignment : cur_assignments)
        {
            // Calculate the number of iterations
            iters++;

            // Obtain the agent, action and aciton-pointer from the tuple
            // The tuple itself was obtained from the combinator above.
            auto agent = assignment.agent;
            auto action = assignment.action;
            auto action_node_id = assignment.action_node_id;

            // auto action_ptr = assembly_graph_.getNode(action_idx);

            // Update the data for the newly-created sueprnode.
            // The subassebmlies/actions have been copied from the current source node.
            // Delete the subassemblies/actions which are applied in the current step,
            // In this way, they are not available in the newly-created node.
            auto action_source_id = assembly_graph_.predecessorNodes(action_node_id).front();
            auto action_source = assembly_graph_.getNodeD(action_source_id).name;
            x.name += action_source + "-" + action + "-" + agent + "   ";
            x.subassemblies.erase(action_source);
            x.actions.erase(action);

            // For the currently applied assignement, update the subassemblies of the new supernode.
            for (auto& successor_id : assembly_graph_.successorNodes(action_node_id))
            {
                auto successor = assembly_graph_.getNodeD(successor_id);
                NodeIndex ors_id = successor_id;

                bool part_reachable = config.subassemblies[successor.name].reachability[agent].reachable;

                if (!part_reachable)
                {
                    // Part not reachable - add Interaction
                    auto interaction = config.subassemblies[successor.name].reachability[agent].interaction;
                    auto interaction_cost = config.actions[interaction].costs[agent];
                    // assembly_graph_
                    ors_id = createInteraction(successor_id, successor, interaction, interaction_cost);
                }

                x.subassemblies[successor.name] = ors_id;

                for (const auto& next_action_id : assembly_graph_.successorNodes(ors_id))
                {
                    auto next_action = assembly_graph_.getNodeD(next_action_id);
                    x.actions[next_action.name] = next_action_id;
                }
            }

            // Update the minimum cost which can be achieved by any agent for any available action.
            if (config.actions[action].costs[agent] < min_action_agent_cost_)
            {
                min_action_agent_cost_ = config.actions[action].costs[agent];
            }

            // Update edge data.
            y.cost += config.actions[action].costs[agent];
            y.planned_assignments.push_back(assignment);
        }

        // Create the average of the edge.cost over the number of nodes it connects.
        // (This edge is a edge connecting supernodes of the search graph).
        // (That is why the average-step is necessary).
        y.cost = y.cost / iters;

        // Insert the newly-created sueprnode into the search-graph.
        auto next_node_id = search_graph_.insertNode(x);

        // Insert the edge connecting the new-sueprnode to the source (old) one.
        search_graph_.insertEdge(y, node_id, next_node_id);
    }

    // Set the minum-agen-action cost for the curent supernode.
    // It is needed for the heuristic used by the A* algorithm.
    node_data.minimum_cost_action = min_action_agent_cost_;
}

/* Returns interactions for subassemblies (parts).
    Interactions are created for assignemnts where a given agent cannot reach a part (subassembly).
**/
NodeIndex NodeExpander::createInteraction(NodeIndex dest_id, NodeData& dest_data, std::string iname, double icost)
{
    // Create interaction subassembly. It cotains same data as original one.
    NodeData tdata = dest_data;
    tdata.name = dest_data.name + "_prime";
    auto or_prime_id = assembly_graph_.insertNode(tdata);
    // Create node for interaction-Action.
    NodeData idata;
    idata.cost = icost;
    idata.name = iname;
    auto interaction_id = assembly_graph_.insertNode(idata);
    //Insert interaction between nodes
    assembly_graph_.insertEdge(EdgeData(), or_prime_id, interaction_id);
    assembly_graph_.insertEdge(EdgeData(), interaction_id, dest_id);
    // Return the interaction subassembly to insert into the current supernode.
    return or_prime_id;
}
