#pragma once

#include <vector>
#include "combinator.hpp"
#include "graph.hpp"
#include <set>

class NodeExpander{

public:
    // Constructr / Destructor
    NodeExpander(Graph<>*, Config*);
    ~NodeExpander();

    // Node Expansion function.
    void expandNode(Node*);

private:

    Node* createInteraction(Node*, Node*);

    Graph<> * search_graph_;
    CostMap* costs_;
    ReachMap* reach_;

    // Assgnemtn generation object and assignemnt container
    Combinator * assignment_generator;
    std::vector< std::vector< std::tuple<std::string, std::string, Node*> > > * assignments_;

    std::vector<Node *> interactions;
};

/* NodeExpander Constructor.
**/
NodeExpander::NodeExpander(Graph<>* graph, Config* config){
    search_graph_ = graph;
    costs_ = config->costs_;
    reach_ = config->reach_;
    assignment_generator = new Combinator(costs_);
}

/* NodeExpander Destructor.
**/
NodeExpander::~NodeExpander(){
    delete assignment_generator;
}

/* Function which performs the node expansion.
**/
void NodeExpander::expandNode(Node* node){

    std::vector<Node*> nodes;
    nodes.reserve(node->data_.subassemblies.size());
    for(auto nd : node->data_.subassemblies) {
        // std::cout << "Current subass:  " << nd.second->data_.name;
        if(nd.second->hasSuccessor())
            nodes.push_back(nd.second);  
    } 

    // Obtain all possible assignement cominations of agents to actions for the current step.
    // The assignment combinations are generated by the Combinator Object.
    assignments_ = assignment_generator->generateAgentActionAssignments(nodes);
    
    // Declare the min/ma cost which needs to be set below.
    double min_action_agent_cost_ = node->data_.minimum_cost_action;
    double max_action_agent_cost_ = 0;

    // Iterate through all possible assignments of agents to available actions.
    for (auto &cur_assignments : *assignments_){

        // Create the data for the created supernode.
        NodeData ndata;
        ndata.subassemblies = node->data_.subassemblies;
        ndata.actions       = node->data_.actions;
        ndata.marked        = false;

        // Create the data for the edge connecting the current sueprnode with the new one.
        EdgeData edata;
        edata.cost = 0;

        // Counter variable. Needed to calculate the average cost for the connecting edge.
        int iters = 0;

        // Iterate through agent-action pairs for the current assignemnt
        for (auto &agent_action_assignment : cur_assignments){   
            iters++;

            // Obtain the agent, action and aciton-pointer from the tuple 
            // The tuple itself was obtained from the combinator above.
            std::string agent  = std::get<0>(agent_action_assignment);
            std::string action = std::get<1>(agent_action_assignment);
            Node * action_ptr  = std::get<2>(agent_action_assignment);
            
            // Update the data for the newly-created sueprnode.
            // The subassebmlies/actions have been copied from the current source node.
            // Delete the subassemblies/actions which are applied in the current step,
            // In this way, they are not available in the newly-created node.
            std::string action_source = action_ptr->getPredecessorNodes().front()->data_.name;
            ndata.name += action_source + "-" + action + "-" + agent + "     ";
            ndata.subassemblies.erase(action_source);
            ndata.actions.erase(action);

            // For the currently applied assignement, update the subassemblies of the new supernode.
            for (auto & or_successor : action_ptr->getSuccessorNodes()){

                // Part not reachable 
                // Add Interaction
                if(reach_->map_[or_successor->data_.name][agent] == INT_MAX){
                    Node * interaction = createInteraction(action_ptr, or_successor);

                    ndata.subassemblies[interaction->data_.name] = interaction;
                    for (auto &following_action : or_successor->getSuccessorNodes()){
                        ndata.actions[following_action->data_.name] = following_action; 
                    }
                }
                else{
                    ndata.subassemblies[or_successor->data_.name] = or_successor;
                    for (auto &following_action : or_successor->getSuccessorNodes()){
                        ndata.actions[following_action->data_.name] = following_action; 
                    }
                }
            }

            // Update the minimum cost which can be achieved by any agent for any available action.
            if(costs_->map_[action][agent] < min_action_agent_cost_){
                min_action_agent_cost_ = costs_->map_[action][agent];
            }

            // Update edge data.
            edata.cost   += costs_->map_[action][agent];
            edata.agent_actions_.push_back(std::make_pair(action, agent));
        }

        // Create the average of the edge.cost over the number of nodes it connects.
        // (This edge is a edge connecting supernodes of the search graph).
        // (That is why the average-step is necessary).
        edata.cost = edata.cost / iters;

        // Insert the newly-created sueprnode into the search-graph.
        Node * next_node = search_graph_->insertNode(ndata);

        // Insert the edge connecting the new-sueprnode to the source (old) one.
        search_graph_->insertEdge(edata, node->id_, next_node->id_);

    }

    // std::cout << "Minmum Agent-Action Cost: " << min_action_agent_cost_ << std::endl;

    // Set the minum-agen-action cost for the curent supernode.
    // It is needed for the heuristic used by the A* algorithm.
    node->data_.minimum_cost_action = min_action_agent_cost_;    
}


/* Inserts interactions for atomic-subassemblies (parts).
    Interactions are created for assignemnts where a given agent cannot reach a Part.
    In this cas, another agent must pass hand_over the requested part. 
**/ 
Node* NodeExpander::createInteraction(Node* source_and, Node* destination_or){

    NodeData tdata = destination_or->data_;
    tdata.name =  destination_or->data_.name + "_prime";
    Node * or_prime = new Node(0, tdata);

    NodeData idata;
    idata.cost = 8;
    idata.name = "i0";
    Node * inter_action = new Node(0, idata);

    EdgeData edata;
    Edge* edge1 = new Edge(edata);
    edge1->setSource(or_prime);
    edge1->setDestination(inter_action);
    or_prime->addSuccessor(edge1);
    inter_action->addPredecessor(edge1);

    Edge* edge2 = new Edge(edata);
    edge2->setSource(inter_action);
    edge2->setDestination(destination_or);
    inter_action->addSuccessor(edge2);
    // inter_action->addPredecessor(edge1);
    // or_prime->addSuccessor();

    return or_prime;

}