#pragma once

#include <vector>
#include <set>

#include "combinator.hpp"
#include "graph.hpp"


/* Class representing the node-expander.
    During the A* search the supernodes need to be expanded.
    This class handles the expansion-step and creates new hypernodes for the A* search_graph.
    It is important to denote that the search itself is performed on a graph of "HyperNodes".
    Every Hypernode contains references to the nodes of the original And/Or graph.
    If interactions are necessary, their insertion into the HyperNodes is handled inside the Expander.
**/
class NodeExpander
{

public:
    // Constructr / Destructor
    NodeExpander(Graph<> *, Config *);
    ~NodeExpander();

    // Node Expansion function.
    // Called by the A*-search on evary iteration.
    void expandNode(Node *);

private:

    // Function used to create Interactions if subassemblies are not reachable.
    Node *createInteraction(Node *, std::string, double);

    // Pointer to the graph of HyperNodes on which the A* search runs.
    Graph<> *search_graph_;

    // Pointers to cost/reach maps provided by the InputReader.
    CostMap *costs_;
    ReachMap *reach_;

    // Assgnemtn generation object and assignemnt container
    Combinator *assignment_generator;
    std::vector<std::vector<std::tuple<std::string, std::string, Node *>>> *assignments_;

    // Vectors used to hold references to the created interactions.
    // Needed to perform memory cleanup, as interactions are allocated in expander.
    std::vector<Node *> interaction_nodes;
    std::vector<Edge *> interaction_edges;
};

/* NodeExpander Constructor.
**/
NodeExpander::NodeExpander(Graph<> *graph, Config *config)
{
    search_graph_ = graph;
    costs_ = config->costs_;
    reach_ = config->reach_;
    assignment_generator = new Combinator(costs_);
}

/* NodeExpander Destructor.
**/
NodeExpander::~NodeExpander()
{
    delete assignment_generator;

    for (auto inode : interaction_nodes)
    {
        delete inode;
    }
    for (auto iedge : interaction_edges)
    {
        delete iedge;
    }
}

/* Function which performs the node expansion.
**/
void NodeExpander::expandNode(Node *node)
{

    std::vector<Node *> nodes;
    nodes.reserve(node->data_.subassemblies.size());
    for (auto nd : node->data_.subassemblies)
    {
        // std::cout << "Current subass:  " << nd.second->data_.name;
        if (nd.second->hasSuccessor())
            nodes.push_back(nd.second);
    }

    // Obtain all possible assignement cominations of agents to actions for the current step.
    // The assignment combinations are generated by the Combinator Object.
    assignments_ = assignment_generator->generateAgentActionAssignments(nodes);

    // Declare the min/ma cost which needs to be set below.
    double min_action_agent_cost_ = node->data_.minimum_cost_action;
    double max_action_agent_cost_ = 0;

    // Iterate through all possible assignments of agents to available actions.
    for (auto &cur_assignments : *assignments_)
    {

        // Create the data for the created supernode.
        NodeData ndata;
        ndata.subassemblies = node->data_.subassemblies;
        ndata.actions = node->data_.actions;
        ndata.marked = false;

        // Create the data for the edge connecting the current sueprnode with the new one.
        EdgeData edata;
        edata.cost = 0;

        // Counter variable. Needed to calculate the average cost for the connecting edge.
        int iters = 0;

        // Iterate through agent-action pairs for the current assignemnt
        for (auto &agent_action_assignment : cur_assignments)
        {
            // Calculate the number of iterations 
            iters++; 

            // Obtain the agent, action and aciton-pointer from the tuple
            // The tuple itself was obtained from the combinator above.
            std::string agent = std::get<0>(agent_action_assignment);
            std::string action = std::get<1>(agent_action_assignment);
            Node *action_ptr = std::get<2>(agent_action_assignment);

            // Update the data for the newly-created sueprnode.
            // The subassebmlies/actions have been copied from the current source node.
            // Delete the subassemblies/actions which are applied in the current step,
            // In this way, they are not available in the newly-created node.
            std::string action_source = action_ptr->getPredecessorNodes().front()->data_.name;
            ndata.name += action_source + "-" + action + "-" + agent + "     ";
            ndata.subassemblies.erase(action_source);
            ndata.actions.erase(action);

            // For the currently applied assignement, update the subassemblies of the new supernode.
            for (auto &or_successor : action_ptr->getSuccessorNodes())
            {
                bool part_reachable = std::get<0>(reach_->map_[or_successor->data_.name][agent]);

                Node *successor;

                if (!part_reachable)
                {
                    // Part not reachable
                    // Add Interaction
                    std::string interaction_name = std::get<1>(reach_->map_[or_successor->data_.name][agent]);
                    double interaction_cost = costs_->map_[interaction_name][agent];
                    successor = createInteraction(or_successor, interaction_name, interaction_cost); // interaction inserted
                }
                else
                {
                    successor = or_successor; // No interaction inserted. Just append the orsuccesor
                }

                ndata.subassemblies[or_successor->data_.name] = successor;
                for (auto &following_action : or_successor->getSuccessorNodes())
                {
                    ndata.actions[following_action->data_.name] = following_action;
                }
            }

            // Update the minimum cost which can be achieved by any agent for any available action.
            if (costs_->map_[action][agent] < min_action_agent_cost_)
            {
                min_action_agent_cost_ = costs_->map_[action][agent];
            }

            // Update edge data.
            edata.cost += costs_->map_[action][agent];
            edata.agent_actions_.push_back(std::make_pair(action_ptr, agent));
        }

        // Create the average of the edge.cost over the number of nodes it connects.
        // (This edge is a edge connecting supernodes of the search graph).
        // (That is why the average-step is necessary).
        edata.cost = edata.cost / iters;

        // Insert the newly-created sueprnode into the search-graph.
        Node *next_node = search_graph_->insertNode(ndata);

        // Insert the edge connecting the new-sueprnode to the source (old) one.
        search_graph_->insertEdge(edata, node->id_, next_node->id_);
    }

    // Set the minum-agen-action cost for the curent supernode.
    // It is needed for the heuristic used by the A* algorithm.
    node->data_.minimum_cost_action = min_action_agent_cost_;
}

/* Returns interactions for subassemblies (parts).
    Interactions are created for assignemnts where a given agent cannot reach a part (subassembly).
**/
Node *NodeExpander::createInteraction(Node *destination_or, std::string i_name, double i_cost)
{
    // Create interaction subassembly. It cotains same data as original one.
    NodeData tdata = destination_or->data_;
    tdata.name = destination_or->data_.name + "_prime";
    Node *or_prime = new Node(0, tdata);
    interaction_nodes.push_back(or_prime);

    // Create node for interaction-Action.
    NodeData idata;
    idata.cost = i_cost;
    idata.name = i_name;
    Node *inter_action = new Node(0, idata);
    interaction_nodes.push_back(inter_action);

    // Connect subassembly with the action.
    EdgeData edata;
    Edge *edge1 = new Edge(edata);
    interaction_edges.push_back(edge1);
    edge1->setSource(or_prime);
    edge1->setDestination(inter_action);
    or_prime->addSuccessor(edge1);
    inter_action->addPredecessor(edge1);

    // Connect the created Interaction-action with the original or_successor
    Edge *edge2 = new Edge(edata);
    interaction_edges.push_back(edge2);
    edge2->setSource(inter_action);
    edge2->setDestination(destination_or);
    inter_action->addSuccessor(edge2);

    // Return the interaction subassembly to insert into the current supernode.
    return or_prime;
}